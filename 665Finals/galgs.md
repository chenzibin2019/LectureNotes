## Graph Algorithms

| Name                           | Where to use                                                          | Basic idea                                                                                                                                                                                             | Running time |
| ------------------------------ | --------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ | ------------ |
| DFS Algorithm                  | DFS                                                                   | Find a node to be thefirst one, going down if next has visited, going back, until all the vertices are visited                                                                                         | O(m+n)       |
| Path finding Algorithm         | Find a path from v to z                                               | Doing DFS, when visit z, return.                                                                                                                                                                       | -            |
| Cycle finding Algorithm        | Find a simple cycle                                                   | Doing DFS, if label is UNEXPLORED, doing pathDFS                                                                                                                                                       | -            |
| BFS Algorithm                  | BFS                                                                   | Form many levels and then form a tree. Find a node, for all the nodes that connected to it, if unexplored, add to that level.                                                                          | O(m+n)       |
| Strong Connectivitiy Algorithm | Diagraph to check is each vertices can reache other.                  | Pick up a vertex, perform DFG then reverse all the direction, perform again, if both reach all, then true.                                                                                             | O(n+m)       |
| Floyd-Warshall's Algorithm     | Get transitive closure(if has a path, then has a direct path)         | Dynamic Programming: For each node x, if a->x->b && a -/-> b, then add a->b                                                                                                                            | -            |
| Topological Sort - Algorithm 1 | Basic idea: if a->b, then x(a)>x(b) && start from no outgoing edge    | While G is not empty, remove nodes without outgoing edge, number from n to 0                                                                                                                           | -            |
| Topological Sort - Using DFS   | --                                                                    | Going down using DFS, if cannot going down, mark from n                                                                                                                                                | O(m+n)       |
| Topological Sort - Using BFS   | --                                                                    | While G is not empty, mark no incoming edge from 0 to n                                                                                                                                                | O(m+n)       |
| Prim-Jarnik's Algorithm        | MST: from a vertex, with minimum total weight                         | Grow from one vertex, constructing cloud. Connect all the vertex using the minimum distance                                                                                                            | O((n+m)logn) |
| Kruskal's Algorithm            | MST: --                                                               | Find the minimum weighted edge to create a cloud, if the endpoints are in different cloud, merge the two cloud. End when the MST has n-1 edges.                                                        | O((n+m)logn) |
| Baruvka's Algorithm            | MST: --                                                               | Grow from one node, let e to be the min-weight edge. if is not in the cloud, add it. End when MST has n-1 edges.                                                                                       | O(mlogn)     |
| Dijkstra's Algorithm           | Shortest path: min total weight from u to v. Without negative weight. | Like broad cast the weight, sum up all the weight, choose the smallest one. d(z) = min{d(z), d(u)+weight(e) } for all incoming edges. Update and keep track ofÂ  parent node if you want to get a tree. | O((n+m)logn) |
| Bellman-Ford Algorithm         | Shortest path: --. With negative weight.                              | Like Dijkstra's Algorithm, you have to update each node, not just from start to end.                                                                                                                   | O(mn)        |
| DAG-based Algorithm            | Shortest path: --. DAG based.                                         | Use topological sort, for all the node in topological order, update the distance.                                                                                                                      | O(n+m)       |
| All-Pair Shortest Path         | Find the min distance between every pair of vertices                  | Form a table, using dynamic programming, going from each node, calculate the min weight.                                                                                                               | O(n^3)       |
| Fork-Fulkerson's Algorithm     | Max-Flow                                                              | For all augmenting path, calculate the Delta, if forward, add the Delta, if backward, minus the Delta.                                                                                                 | O(|f*|(n+m)  |
| Edmonds-Karp Algorithm         | Max-Flow                                                              | Use good algorithms to find a good augumenting path, find the path with smallest edges.                                                                                                                | O(nm^2)      |


